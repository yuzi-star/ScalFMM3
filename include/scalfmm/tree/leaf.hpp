// --------------------------------
// See LICENCE file at project root
// File : leaf.hpp
// --------------------------------
#ifndef SCALFMM_TREE_LEAF_HPP
#define SCALFMM_TREE_LEAF_HPP

#warning("Do not use this file - old leaf format")

//#include <xsimd/config/xsimd_config.hpp>
#include <algorithm>
#include <any>
#include <array>
#include <cmath>
#include <cstddef>
#include <iterator>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>

#include "scalfmm/container/particle_container.hpp"
#include "scalfmm/container/point.hpp"
#include "scalfmm/container/variadic_adaptor.hpp"
#include "scalfmm/meta/traits.hpp"
#include "scalfmm/meta/type_pack.hpp"
#include "scalfmm/meta/utils.hpp"
#include "scalfmm/tags/tags.hpp"
#include "scalfmm/tree/group.hpp"
#include "scalfmm/tree/header.hpp"
#include "scalfmm/tree/utils.hpp"
#include "scalfmm/utils/massert.hpp"
#include "scalfmm/utils/math.hpp"

namespace scalfmm::component
{

    /// @brief This is the leaf type stored at the bottom of the tree.
    /// Its stores the particle container and some symbolics informations.
    ///
    /// @tparam Particle : the type of particle to store.
    template<typename Particle, typename D = void>
    class leaf
    {
      public:
        // static dimension of the particle
        static constexpr std::size_t dimension = Particle::dimension;
        // self type
        using self_type = leaf<Particle>;
        // Symbolic types : the type storing informations about the leaf component
        using symbolics_type = symbolics_data<std::conditional_t<std::is_void_v<D>, self_type, D>>;
        // the particle type stored in the container
        using particle_type = Particle;
        using proxy_type = typename Particle::proxy_type;
        using const_proxy_type = typename Particle::const_proxy_type;
        // the position type extract from the symbolic information
        using position_type = typename Particle::position_type;
        // symbolics_type::position_type;
        // the position value type
        using value_type = typename position_type::value_type;
        // the particle container type
        using particle_container_type = container::particle_container<particle_type>;

        // rule of five generated by the compiler
        leaf() = default;
        leaf(leaf const&) = default;
        leaf(leaf&&) noexcept = default;
        inline auto operator=(leaf const&) -> leaf& = default;
        inline auto operator=(leaf&&) noexcept -> leaf& = default;
        ~leaf() = default;

        /// @brief Constructors from center and width
        ///
        /// @param center : the center of the leaf
        /// @param width : the width of the leaf
        leaf(position_type const& center, value_type width)
          : m_center(center)
          , m_width(width)
        {
        }

        /// @brief Constructors from number of particles, center, width and a morton index
        ///
        /// @param nb_particles : number of particles in the container
        /// @param center : the center of the leaf
        /// @param width : the width of the leaf
        /// @param morton_index : the morton index of the leaf
        leaf(std::size_t nb_particles, position_type const& center, value_type width, std::size_t morton_index)
          : m_particles(nb_particles)
          , m_symbolics{morton_index}
          , m_nb_particles(nb_particles)
          , m_center(center)
          , m_width(width)
        {
            m_symbolics.morton_index = morton_index;
        }

        /// @brief
        /// Constructors from a container of particles, center, width and a morton index
        /// It takes an rvalue reference to the container allowing you to move the container inside the leaf.
        ///
        /// @param container : rvalue ref to the container
        /// @param nb_particles : number of particles
        /// @param center : the center of the leaf
        /// @param width : the width of the leaf
        /// @param morton_index : the morton index of the leaf
        leaf(particle_container_type&& container, std::size_t nb_particles, position_type const& center,
             value_type width, std::size_t morton_index)
          : m_particles(container)
          , m_symbolics{morton_index}
          , m_nb_particles(nb_particles)
          , m_center(center)
          , m_width(width)
        {
        }

        /// @brief Constructors from a container of particles with iterators, center, width and a morton index
        ///
        /// @param begin : iterator on the begin of the particle container to copy
        /// @param end : iterator on the end of the particle container to copy
        /// @param nb_particles : number of particles
        /// @param center : the center of the leaf
        /// @param width : the width of the leaf
        /// @param morton_index : the morton index of the leaf
        leaf(typename particle_container_type::const_iterator begin,
             typename particle_container_type::const_iterator end, std::size_t nb_particles,
             position_type const& center, value_type width, std::size_t morton_index)
          : m_particles(nb_particles)
          , m_symbolics{morton_index}
          , m_nb_particles(nb_particles)
          , m_center(center)
          , m_width(width)
        {
            std::copy(begin, end, std::begin(m_particles));
        }

        /// @brief Returns the center of the leaf
        ///
        /// @return position_type
        [[nodiscard]] inline auto center() const noexcept -> position_type const& { return m_center; }
        /// @brief Returns the width of the leaf
        ///
        /// @return value_type
        [[nodiscard]] inline auto width() const noexcept -> value_type { return m_width; }
        /// @brief Return the number of particles
        ///
        /// @return std::size_t
        [[nodiscard]] inline auto size() const noexcept -> std::size_t { return m_nb_particles; }

        /// @brief Non const accessor on the container
        ///
        /// @return a reference on the particle_container_type
        [[nodiscard]] inline auto particles() -> particle_container_type& { return m_particles; }
        /// @brief Const accessor on the container
        ///
        /// @return a const reference on the particle_container_type
        [[nodiscard]] inline auto particles() const -> particle_container_type const& { return m_particles; }
        /// @brief Const accessor on the container
        ///
        /// @return a const reference on the particle_container_type
        [[nodiscard]] inline auto cparticles() const -> particle_container_type const& { return m_particles; }

        /// @brief Indexed accessor on the particle container
        ///
        /// @param i : the index at which the access is performed.
        ///
        /// @return a particle_type reference
        [[nodiscard]] inline auto particles(std::size_t i) -> particle_type& { return m_particles.at(i); }
        [[nodiscard]] inline auto particle(std::size_t i) -> particle_type& { return m_particles.at(i); }
        /// @brief Indexed accessor on the particle container
        ///
        /// @param i : the index at which the access is performed.
        ///
        /// @return a particle_type const reference
        [[nodiscard]] inline auto particles(std::size_t i) const -> particle_type const& { return m_particles.at(i); }
        [[nodiscard]] inline auto particle(std::size_t i) const -> particle_type const& { return m_particles.at(i); }

        [[nodiscard]] inline auto begin() -> typename particle_container_type::iterator { return m_particles.begin(); }
        [[nodiscard]] inline auto begin() const -> typename particle_container_type::const_iterator
        {
            return m_particles.begin();
        }
        [[nodiscard]] inline auto cbegin() const -> typename particle_container_type::const_iterator
        {
            return m_particles.cbegin();
        }

        [[nodiscard]] inline auto end() -> typename particle_container_type::iterator { return m_particles.end(); }
        [[nodiscard]] inline auto end() const -> typename particle_container_type::const_iterator
        {
            return m_particles.end();
        }
        [[nodiscard]] inline auto cend() const -> typename particle_container_type::const_iterator
        {
            return m_particles.cend();
        }

        /// @brief Access to the symbolic type
        ///
        /// @return a symbolics_type reference
        [[nodiscard]] inline auto symbolics() -> symbolics_type& { return m_symbolics; }
        /// @brief Access to the symbolic type
        ///
        /// @return a const symbolics_type reference
        [[nodiscard]] inline auto symbolics() const -> symbolics_type const& { return m_symbolics; }
        /// @brief Access to the symbolic type
        ///
        /// @return a const symbolics_type reference
        [[nodiscard]] inline auto csymbolics() const -> symbolics_type const& { return m_symbolics; }

        /// @brief Returns the morton index of the leaf
        ///
        /// @return std::size_t
        [[nodiscard]] inline auto index() const noexcept -> std::size_t { return m_symbolics.morton_index; }

        /// @brief Insert a particle at the index
        ///
        /// @param part : the particle to insert
        /// @param index : the position to insert the particle
        ///
        /// @return void
        inline auto insert_particle(particle_type const& part, std::size_t index) -> void
        {
            assertm(index < m_nb_particles, "Inserting particle out of range in leaf.");
            auto it = std::begin(m_particles) + index;
            *it = part.as_tuple();
        }

        /// @brief Insert a particle at the index
        ///
        /// @param part : the tuple corresponding to the particle to insert
        /// @param index : the position to insert the particle
        ///
        /// @return void
        template<typename... Types>
        inline auto insert_particle(std::tuple<Types...> const& part, std::size_t index) -> void
        {
            assertm(index < m_nb_particles, "Inserting particle out of range in leaf.");
            auto it = std::begin(m_particles);
            std::advance(it, index);
            *it = part;
        }

        ///
        /// \brief reset_outputs reset  outputs in the leaf
        ///
        inline void reset_outputs()
        {
            //
            m_particles.reset_outputs();
        }

      private:
        // The particle container
        particle_container_type m_particles{};
        // The symbolic type
        symbolics_type m_symbolics{};
        // The number of particles
        std::size_t m_nb_particles{};
        // Position of the center
        position_type m_center{};
        // The width of the leaf
        value_type m_width{};
    };

    /// @brief The symbolics type stores information about the leaf
    /// It represents a generic that also exists on the cells
    ///
    /// @tparam P
    template<typename P>
    struct symbolics_data<leaf<P>>
    {
        // the leaf type
        using component_type = leaf<P>;
        // the group type
        using group_type = group<component_type>;
        // the position type
        using position_type = typename component_type::particle_type::position_type;   // container::point<position_value_type,
                                                                                       // P::dimension>;
        // the coordinate type to store the coordinate in the tree
        using coordinate_type =
          decltype(index::get_coordinate_from_morton_index<position_type::dimension>(std::size_t{}));
        //
        // the number of interactions of the leaf
        static constexpr std::size_t number_of_interactions{int(math::pow(3, position_type::dimension))};
        // type of the array storing the indexes of the theoretical interaction list
        using interaction_index_array_type = std::array<std::size_t, number_of_interactions>;
        // type of the array storing the iterators of the interacting leaves available in the current group
        using iterator_array_type = std::array<typename group_type::iterator_type, number_of_interactions>;
        using iterator_type = typename iterator_array_type::value_type;
        // the morton index of the leaf

        std::size_t morton_index{0};
        // the array storing the indexes of the theoretical interaction list
        interaction_index_array_type interaction_indexes{};
        // the array storing the iterators of the interacting leaves available in the current group
        iterator_array_type interaction_iterators{};
        // the theoretical number of neighbors or the Number of Morton index available in Mutual algo
        std::size_t number_of_neighbors{0};
        // the number of Morton index available in the group of the leaf
        std::size_t existing_neighbors_in_group{0};

        void set(int counter, std::size_t const& idx, const iterator_type& leaf_iter)
        {
            interaction_iterators.at(counter) = leaf_iter;
        }
        void finalize(bool done, std::size_t const& counter_existing_component)
        {
            number_of_neighbors = counter_existing_component;
        }
    };

    /// @brief The Symbolics type that stores information about the groupe of leaves
    ///
    /// @tparam P
    template<typename P>
    struct symbolics_data<group<leaf<P>>>
    {
        // the leaf type
        using component_type = leaf<P>;
        // the group type
        using group_type = group<leaf<P>>;
        // the particle type is also P
        using particle_type = typename component_type::particle_type;
        using particle_container_type = container::particle_container<particle_type>;

        using iterator_type = typename group_type::iterator_type;
        using seq_iterator_type =
          std::conditional_t<meta::exist_v<meta::inject<group_type>>, meta::exist_t<meta::inject<group_type>>,
                             std::tuple<typename group_type::iterator_type, group_type>>;
        using iterator_source_type = std::tuple_element_t<0, seq_iterator_type>;
        //    using iterator_array_type = std::array<iterator_source_type, number_of_interactions>;
        using out_of_block_interaction_type = out_of_block_interaction<iterator_type, std::size_t>;
        // the starting morton index in the group
        std::size_t starting_index{0};
        // the ending morton index in the group
        std::size_t ending_index{0};
        // number of leaves in the group
        std::size_t number_of_component_in_group{0};
        // number of particles in group
        std::size_t number_of_particles_in_group{0};
        // index of the group
        std::size_t idx_global{0};
        //
        bool is_mine{false};
        // vector storing the out_of_block_interaction structure to handle the outside interactions
        std::vector<out_of_block_interaction_type> outside_interactions{};
        // flagged if the vector is constructed
        bool outside_interactions_exists{false};
        // flagged if the vector is sorted
        bool outside_interactions_sorted{false};
#if _OPENMP
        // the dependencies are set on the pointer on leaf group (same as particles container)
        std::vector<group_type*> group_dependencies{};
#endif

        symbolics_data<group<leaf<P>>>(size_t starting_morton_idx, size_t ending_morton_idx, size_t number_of_component,
                                       size_t in_index_global, bool in_is_mine)
          : starting_index(starting_morton_idx)
          , ending_index(ending_morton_idx)
          , number_of_component_in_group(number_of_component)
          , number_of_particles_in_group(0)
          , idx_global(in_index_global)
          , is_mine(in_is_mine)
        {
        }
    };

}   // namespace scalfmm::component

#endif   // SCALFMM_TREE_TREE_HPP
